# -*- coding: utf-8 -*-
#
# Copyright Â© 2011-2013 Last.fm Limited
#
# This file is part of python-mirbuild.
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

r"""
CMake specific classes

This file contains CMake specific implementations of mirbuild classes.

"""

__author__ = 'Marcus Holland-Moritz <marcus@last.fm>'
__all__ = 'CMakeProject CMakeTestBuilder'.split()

import copy, json, os, stat, sys, errno, re
import mirbuild.project, mirbuild.test, mirbuild.environment, mirbuild.dependency, glob
from mirbuild.tools import ScopedChdir, LazyFileWriter
from mirbuild.options import LocalOptions
from optparse import OptionGroup

class CMakeWriter(LazyFileWriter):
    def __init__(self, name):
        LazyFileWriter.__init__(self, name)
        self.__scopestack = []

    def write(self, *args):
        super(CMakeWriter, self).write('   '*len(self.__scopestack))
        super(CMakeWriter, self).write(*args)

    def writeln(self, *args):
        self.write('{0}\n'.format(' '.join(args)))

    def newline(self):
        self.writeln('')

    def header(self, project_name, ident):
        self.writeln('#\n# build configuration for {0} (generated by {1})\n#\n'.format(project_name, ident))

    def comment(self, str):
        self.writeln('# {0}'.format(str))

    def write_list(self, args):
        self.__scopestack.append(None)
        for item in args:
           self.writeln('{0}'.format(item))
        self.__scopestack.pop()

    def cmd_list(self, cmd, args):
        self.writeln('{0}('.format(cmd))
        self.write_list(args)
        self.writeln(')')

    def cmd(self, cmd, *args):
        self.writeln('{0}({1})'.format(cmd, ' '.join(args)))

    def set(self, var, value):
        self.writeln('SET({0} {1})'.format(var, value))

    def c_if(self, cond):
        self.writeln('IF({0})'.format(cond))
        self.__scopestack.append(cond)

    def c_else(self):
        cond = self.__scopestack.pop()
        self.writeln('ELSE({0})'.format(cond))
        self.__scopestack.append(cond)

    def c_endif(self):
        self.writeln('ENDIF({0})'.format(self.__scopestack.pop()))

    def c_function(self, name, *args):
        self.writeln('FUNCTION({0}{1}{2})'.format(name, ' ' if args else '', ' '.join(args)))
        self.__scopestack.append(name)

    def c_endfunction(self):
        self.writeln('ENDFUNCTION({0})'.format(self.__scopestack.pop()))

    def platform_cmd(self, platform, command):
        # Map our names to cmakes own names for platforms.
        # NB. UNIX is a CMake Boolean variable set
        # to either true or false depending on the platform
        # See http://bit.ly/pXgOdo for more information.
        platform_map = {
            'UNIX': 'UNIX',
            'CYGWIN':'CYGWIN',
            'POSIX':'UNIX',
            }

        # convert platform to cmake supported
        platform = platform.upper()
        cmake_platform = platform_map[platform.upper()]

        # implement the platform specific command function
        self.c_function('{0}_{1}'.format(command, platform))
        self.c_if(cmake_platform)
        self.cmd(command, '${ARGV}')
        self.c_endif()
        self.c_endfunction()

    def posix_cmd(self, command):
        self.platform_cmd('posix', command)

    def cygwin_cmd(self, command):
        self.platform_cmd('cygwin', command)

    def xplatform_cmd(self, command):
        self.posix_cmd(command)
        self.cygwin_cmd(command)

    def set_policy(self, policy, value):
        self.c_if('POLICY {0}'.format(policy))
        self.writeln('CMAKE_POLICY(SET {0} {1})'.format(policy, value))
        self.c_endif()

class CMakeEnvironment(mirbuild.environment.Environment):
    @property
    def _cmake_files(self):
        return ['cmake_install.cmake', 'cmake_uninstall.cmake.in',
                'cmake_uninstall.cmake', 'CMakeCache.txt', 'CPackConfig.cmake',
                'CPackSourceConfig.cmake', 'Makefile']
    @property
    def _generator(self):
        if getattr(self._options, 'cmake_generator', None) is not None:
            return ''.join(self._options.cmake_generator)
        else:
            return None

    def third_party_libs(self, *libs):
        # At this time there is no special convention for any supported platform
        return ' '.join(libs)

    def _build_out_of_source(self, args):
        # If we were previously building 'in-source' we'll need to clean any
        # existing cmake cache files otherwise cmake will ignore the oos request!
        # NB. This only removes cmake generated files!
        self.realclean()

        # If we're building oos we'll probably need to create the oos dir
        if not os.path.exists(self.build_dir):
            self.make_dirs(self.build_dir)

        # To build oos we cd to dest dir then run cmake referencing the CMakeLists.txt folder
        scd = ScopedChdir(self.build_dir)
        args.append(scd.original_dir)
        self.execute(*args)

    def _build_in_source(self, args):
        # remove out of source (oos) stuff
        self.remove_trees(self.oosbuild_dir)
        args.append(self.build_dir)
        self.execute(*args)

    def cmake(self):
        args = [self.tool('cmake')]
        if self.trace:
            args.append('--debug-output')
            args.append('--trace')

        if self._generator:
            args.append('-G{0}'.format(self._generator))

        if self.has_tool('cxx'):
            args.append('-DCMAKE_CXX_COMPILER=' + self.tool('cxx'))
        if self.has_tool('cc'):
            args.append('-DCMAKE_C_COMPILER=' + self.tool('cc'))

        if self.out_of_source:
            self._build_out_of_source(args)
        else:
            self._build_in_source(args)

    def _cmake_build(self, target):
        # CMake has its own in-built way to build x-platform so let's use it :)
        opts = ['--build', self.build_dir]
        if target is not None:
            opts += ['--target', target]
        opts.append('--')
        opts.append('-j{0}'.format(self.parallel_builds))
        self.execute(self.tool('cmake'), *opts)

    def _make_build(self, target):
        opts = ['-j{0}'.format(self.parallel_builds), '-C{0}'.format(self.build_dir)]
        if target is not None:
            opts.append(target)
        self.execute(self.tool('make'), *opts)

    @property
    def _build_tool(self):
        buildtool = self.get('cmake', 'build_tool', 'cmake')
        if getattr(self, '_' + buildtool + '_build', None) is None:
            self.warn('Build tool "{0}" not recognised, falling back to cmake build\n'.format(buildtool))
            buildtool = 'cmake'
        return buildtool

    def build(self, target = None):
        getattr(self, '_' + self._build_tool + '_build')(target)

    def install(self, *args):
        self.make('install', *args)

    def uninstall(self):
        self.make('uninstall')

    def clean(self):
        if self.can_make():
            self.cmake()
            self.build('clean')

    def __remove_vstudio_files(self, r):
        # Find files/dirs relating to this solution...
        for pattern in ['*.sln', '*.vcproj*', '*.vcxproj*', '*.filters*', '*.ncb', '*.suo', '*.dir']:
            # ...and remove them
            for file in glob.glob(pattern):
                # remove files and dirs that match
                path = os.path.join(r, file)
                try:
                    # See if it's a file first
                    self.remove_files(path)
                except OSError as e:
                    # Nah, so it's probably a dir
                    if e.errno in [errno.EISDIR, errno.EACCES, errno.EPERM] and os.path.isdir(path):
                        self.remove_trees(path)
                    else:
                        # OMG --- Dragons!!!
                        raise

    def realclean(self):
        for r, d, f in os.walk('.'):
            if 'CMakeLists.txt' in f:
                self.__remove_vstudio_files(r)
                for file in self._cmake_files:
                    self.remove_files(os.path.join(r, file))
                self.remove_trees(os.path.join(r, 'CMakeFiles'))

class CMakeTestBuilder(mirbuild.test.TestBuilder):
    def __init__(self, env, dir, *args):
        mirbuild.test.TestBuilder.__init__(self, env, dir, *args)

    @staticmethod
    def looks_like_test_dir(dir):
        return os.path.exists(os.path.join(dir, 'CMakeLists.txt'))

    def configure(self):
        if self.dir is not None:
            scd = ScopedChdir(self.dir)
            self._env.cmake()

    def build(self):
        if self.dir is not None:
            scd = ScopedChdir(self.dir)
            self._env.build()
            if not self.tests:
                self.__find_tests()

    def __find_tests(self):
        for e in os.listdir(self._env.bin_dir):
            epath = os.path.join(self._env.bin_dir, e)
            if os.path.isfile(epath) and os.stat(epath).st_mode & stat.S_IXUSR:
                self.add_test(e)

    def clean(self):
        if self.dir is not None:
            scd = ScopedChdir(self.dir)
            self._env.clean()
            self._env.realclean()
            self._env.remove_dirs(self._env.bin_dir)

def _add_shared_library_cmd(cm, coverage = False):
    # For coverage configurations, we need to explicitly link DSOs
    # against the gcov library
    cm.comment('Special handling for shared libraries')
    cm.c_function('ADD_SHARED_LIBRARY', '_LIBNAME')
    cm.cmd('ADD_LIBRARY', '${_LIBNAME}', 'SHARED', '${ARGN}')
    if coverage:
        cm.cmd('TARGET_LINK_LIBRARIES', '${_LIBNAME}', 'gcov')
    cm.c_endfunction()
    cm.newline()

class CMakeConfigWindows(object):
    cmake_config_name = "Windows"

    def __configure(self, cm):
        _add_shared_library_cmd(cm)

        cm.comment('Build options')

        # Without this multiple configuration builders will append the
        # config name to the output folder (eg. lib/debug or lib/release)
        cfg = self.env.build_config.upper()
        cm.set('CMAKE_LIBRARY_OUTPUT_DIRECTORY_{0}'.format(cfg), '${PROJECT_BINARY_DIR}/lib')
        cm.set('CMAKE_ARCHIVE_OUTPUT_DIRECTORY_{0}'.format(cfg), '${PROJECT_BINARY_DIR}/lib')
        cm.set('CMAKE_RUNTIME_OUTPUT_DIRECTORY_{0}'.format(cfg), '${PROJECT_BINARY_DIR}/bin')

    def configure_release(self, cm):
        # release build options automatically added by cmake
        self.__configure(cm)

    def configure_debug(self, cm):
        # debug build options automatically added by cmake
        self.__configure(cm)

class CMakeConfigPOSIX(object):
    cmake_config_name = "POSIX"

    def __configure(self, cm, coverage = False):
        _add_shared_library_cmd(cm, coverage)

        cm.comment('Build options')
        cm.cmd('ADD_DEFINITIONS_POSIX', '-Wall -g')

        if self.project_name.startswith(('lib', 'thrift-')):
            # -fPIC is needed as radio's shared libraries link against other libs
            # TODO: We can probably find a way to make only library objects build with -fPIC,
            # but this seems to be non-trivial with CMake...
            cm.cmd('ADD_DEFINITIONS_POSIX', '-fPIC')

    def configure_release(self, cm):
        self.__configure(cm)
        cm.cmd('ADD_DEFINITIONS_POSIX', '-O2 -DNDEBUG')

    def configure_debug(self, cm, coverage = False):
        self.__configure(cm, coverage)
        cm.cmd('ADD_DEFINITIONS_POSIX', '-Wextra')

    def configure_coverage(self, cm):
        self.configure_debug(cm, True)
        cm.cmd('ADD_DEFINITIONS_POSIX', '-fprofile-arcs -ftest-coverage')
        cm.set('CMAKE_EXE_LINKER_FLAGS', '"${CMAKE_EXE_LINKER_FLAGS} -fprofile-arcs -ftest-coverage"')

if sys.platform.startswith('linux') or sys.platform in ['cygwin']:
    CMakeConfigPlatform = CMakeConfigPOSIX
else:
    class CMakeConfigPlatform(object):
        cmake_config_name = "default"

class CMakeCoverage(object):
    def __init__(self, env, optparser, cache):
        self.__env = env
        self.__root = env.getcwd()
        self.__exclude = []
        self.__opt = LocalOptions('coverage')
        cache.register(self.__opt)

        if self.__env.has('tools', 'gcovr'):
            self.__opt.state_merge({ 'gcovr_path': self.__env.get('tools', 'gcovr') })

        cover = OptionGroup(optparser, "CMake Coverage Options")
        self.__opt.add_bool_option(cover, '--coverage-xml', dest = 'xml', help = 'generate XML output', cache = False)
        self.__opt.add_bool_option(cover, '--coverage-keep', dest = 'keep', help = 'keep intermediate output', cache = False)
        self.__opt.add_option(cover, '--coverage-output', type = 'string', dest = 'output', metavar = 'FILE',
                                     help = 'write output to this file', cache = False)
        self.__opt.add_option(cover, '--coverage-gcovr-path', type = 'string', default = '/usr/bin/gcovr', dest = 'gcovr_path',
                                     metavar = 'FILE', help = 'location of gcovr script')
        optparser.add_option_group(cover)

    def __cleanup_gcov_mess(self):
        for root, dirs, files in os.walk(self.__env.getcwd()):
            for f in files:
                if f.endswith('.gcov'):
                    source = os.path.join(root, f)
                    target = f.replace('#', '/')
                    trel = target if self.__root is None else os.path.relpath(target, self.__root)
                    if self.__opt.keep and (self.__root is None or target.startswith(self.__root)) and not any(re.match(e, trel) for e in self.__exclude):
                        self.__env.move(source, target, False)
                    else:
                        self.__env.remove_files(source)

    def exclude(self, *args):
        self.__exclude += args

    def set_root(self, root):
        self.__root = root

    def run(self):
        options = []
        if self.__root is not None:
            options += ['-r', self.__root]
        if self.__exclude:
            for re in self.__exclude:
                options += ['-e', re]
        if self.__opt.output is not None:
            options += ['-o', self.__opt.output]
        if self.__opt.keep:
            options += ['--keep']
        if self.__opt.xml:
            options += ['--xml']
        self.__env.execute(self.__opt.gcovr_path, *options)
        self.__cleanup_gcov_mess()

class CMakeProject(mirbuild.project.Project, CMakeConfigPlatform):
    test_builder_class = CMakeTestBuilder
    environment_class = CMakeEnvironment
    default_dependency_class = mirbuild.dependency.CLibraryDependency

    def __init__(self, name, **opts):
        mirbuild.project.Project.__init__(self, name, **opts)

        self.opt.ensure_value('define', json.loads(self.env.get('build', 'define', '[]')))
        self.add_option('-D|--define', dest = 'define', type = 'string', multi = True,
                        metavar = 'MACRO', help = 'additional macro definition')

        self.opt.ensure_value('compiler_flag', json.loads(self.env.get('build', 'compiler_flag', '[]')))
        self.add_option('--compiler-flag', dest = 'compiler_flag', type = 'string', multi = True,
                        metavar = 'ARG', help = 'additional flag to pass to the C/C++ compiler')

        self.opt.ensure_value('c_compiler_flag', json.loads(self.env.get('build', 'c_compiler_flag', '[]')))
        self.add_option('--c-compiler-flag', dest = 'c_compiler_flag', type = 'string', multi = True,
                        metavar = 'ARG', help = 'additional flag to pass to the C compiler')

        self.opt.ensure_value('cxx_compiler_flag', json.loads(self.env.get('build', 'cxx_compiler_flag', '[]')))
        self.add_option('--cxx-compiler-flag', dest = 'cxx_compiler_flag', type = 'string', multi = True,
                        metavar = 'ARG', help = 'additional flag to pass to the C++ compiler')

        self.opt.ensure_value('cmake_generator', json.loads(self.env.get('build', 'cmake_generator', '[]')))
        self.add_option('--cmake-generator', dest = 'cmake_generator', type = 'string', multi = True,
                        metavar = 'ARG', help = 'specify a specific cmake generator to use instead of the platform default')

        self.__defines = {}
        self.__incpath = []
        self.__libpath = []
        self.__thriftspath = []
        self.__cmake_vars = []
        self.__pkgs = []
        self.__coverage = CMakeCoverage(self.env, self._option_parser, self._configure_cache)

    def run_coverage(self):
        if self.build_config != 'coverage':
            raise RuntimeError('project not built with coverage configuration')
        self.__coverage.run()

    @property
    def coverage(self):
        return self.__coverage

    def run_uninstall(self):
        self.do_uninstall()

    def define(self, name, value = None):
        if isinstance(name, basestring):
            self.__defines[name] = value
        else:
            self.__defines.update(name)

    def add_include_path(self, *args):
        self.__incpath += args

    def add_library_path(self, *args):
        self.__libpath += args

    def add_thrifts_path(self, *args):
        self.__thriftspath += args

    def set_cmake_var(self, var, value):
        self.__cmake_vars.append((var, value))

    def __get_define_string(self):
        ds = []
        for k, v in self.__defines.iteritems():
            if v is None:
                ds.append('-D' + k)
            else:
                ds.append('-D' + k + '=' + v)
        for v in self.opt.define:
            ds.append('-D' + v)
        return ' '.join(ds)

    def __create_uninstall_target(self, cm):

        cm.writeln('''
# Create uninstall target
FILE(WRITE cmake_uninstall.cmake.in
   "IF(COMMAND cmake_policy)\\n"
   "   IF(POLICY CMP0007)\\n"
   "      CMAKE_POLICY(SET CMP0007 OLD)\\n"
   "   ENDIF(POLICY CMP0007)\\n"
   "ENDIF(COMMAND cmake_policy)\\n"
   "\\n"
   "IF (NOT EXISTS \\"\\@CMAKE_CURRENT_BINARY_DIR\\@/install_manifest.txt\\")\\n"
   "    MESSAGE(FATAL_ERROR \\"Cannot find install manifest: @CMAKE_CURRENT_BINARY_DIR\\@/install_manifest.txt\\")\\n"
   "ENDIF(NOT EXISTS \\"\\@CMAKE_CURRENT_BINARY_DIR\\@/install_manifest.txt\\")\\n"
   "\\n"
   "FILE(READ \\"\\@CMAKE_CURRENT_BINARY_DIR\\@/install_manifest.txt\\" files)\\n"
   "STRING(REGEX REPLACE \\"\\\\n\\" \\";\\" files \\"\\${files}\\")\\n"
   "LIST(REVERSE files)\\n"
   "\\n"
   "FOREACH (file \\${files})\\n"
   "    MESSAGE(STATUS \\"Uninstalling \\$ENV{DESTDIR}\\${file}\\")\\n"
   "    if (EXISTS \\"\\$ENV{DESTDIR}\\${file}\\")\\n"
   "        EXECUTE_PROCESS(\\n"
   "            COMMAND \\@CMAKE_COMMAND\\@ -E remove \\"\\$ENV{DESTDIR}\\${file}\\"\\n"
   "            OUTPUT_VARIABLE rm_out\\n"
   "            RESULT_VARIABLE rm_retval\\n"
   "        )\\n"
   "        IF(NOT \\${rm_retval} EQUAL 0)\\n"
   "            MESSAGE(FATAL_ERROR \\"Problem when removing \\$ENV{DESTDIR}\\${file}\\")\\n"
   "        ENDIF (NOT \\${rm_retval} EQUAL 0)\\n"
   "    ELSE (EXISTS \\"\\$ENV{DESTDIR}\\${file}\\")\\n"
   "        MESSAGE(STATUS \\"File \\$ENV{DESTDIR}\\${file} does not exist.\\")\\n"
   "    ENDIF (EXISTS \\"\\$ENV{DESTDIR}\\${file}\\")\\n"
   "ENDFOREACH(file)\\n"
)

IF(NOT TARGET uninstall)
   CONFIGURE_FILE(
      "${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in"
      "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
      IMMEDIATE @ONLY
      )

   ADD_CUSTOM_TARGET(uninstall
      COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)
ENDIF()
''')

    def do_configure(self):
        self.env.say("Using {0} CMake configuration.".format(self.cmake_config_name))

        cm = CMakeWriter('config.cmake')
        cm.create()
        cm.header(self.project_name, self.ident)

        cm.comment('Declare the minimum CMake version')
        cm.set('CMAKE_MINIMUM_REQUIRED', '2.8')
        cm.newline()

        cm.comment('Set build type')
        if self.has_build_configs:
            cm.set('CMAKE_BUILD_TYPE', self.build_config)
            cm.newline()

        cm.comment('Set CMake build policies')
        cm.c_if('COMMAND cmake_policy')
        cm.set_policy('CMP0003', 'NEW')
        cm.set_policy('CMP0011', 'OLD')
        cm.c_endif()
        cm.newline()

        cm.comment('Platform specific version of standard CMake commands')
        for cmd in [ 'TARGET_LINK_LIBRARIES',
                     'ADD_DEFINITIONS',
                     'INCLUDE_DIRECTORIES' ]:
            cm.xplatform_cmd(cmd)
            cm.newline()

        # Add own lib-path so unit-tests can link back
        self.__libpath.append(os.path.abspath(os.path.join(self.env.build_dir, 'lib')))

        cm.comment('Setup output Directories')
        cm.set('CMAKE_LIBRARY_OUTPUT_DIRECTORY', '${PROJECT_BINARY_DIR}/lib')
        cm.set('CMAKE_ARCHIVE_OUTPUT_DIRECTORY', '${PROJECT_BINARY_DIR}/lib')
        cm.set('CMAKE_RUNTIME_OUTPUT_DIRECTORY', '${PROJECT_BINARY_DIR}/bin')
        cm.newline()

        cm.comment('Project revision numbers')
        version_info = mirbuild.version.VersionInfoFactory.create()
        cm.set('PROJECT_FULL_REVISION', version_info.full_version())
        cm.set('PROJECT_REVISION', version_info.upstream_version())
        cm.set('PROJECT_MAJOR_VERSION', version_info.major_rev())
        cm.set('PROJECT_MINOR_VERSION', version_info.minor_rev())
        cm.set('PROJECT_PATCHLEVEL', version_info.patchlevel())
        cm.newline()

        cm.comment('Set install path prefix')
        cm.set('CMAKE_INSTALL_PREFIX', self.opt.prefix)

        if self.opt.compiler_flag or self.opt.c_compiler_flag:
            cm.set('CMAKE_C_FLAGS', '"${CMAKE_C_FLAGS} ' + ' '.join(self.opt.compiler_flag + self.opt.c_compiler_flag) + '"')

        if self.opt.compiler_flag or self.opt.cxx_compiler_flag:
            cm.set('CMAKE_CXX_FLAGS', '"${CMAKE_CXX_FLAGS} ' + ' '.join(self.opt.compiler_flag + self.opt.cxx_compiler_flag) + '"')

        cm.set('PYTHON', os.path.realpath(sys.executable))

        if self.env.verbose:
            cm.set('CMAKE_VERBOSE_MAKEFILE', 'ON')

        cm.newline()

        if self.__defines:
            cm.comment('Add general compile time definitions')
            cm.cmd('ADD_DEFINITIONS', self.__get_define_string())
            cm.newline()


        if self.has_build_configs:
            getattr(self, 'configure_' + self.build_config)(cm)

        for v in self.__cmake_vars:
            cm.set(v[0], v[1])

        cm.newline()

        for p in self.__pkgs:
            p.configure(self.env, self.build_config, cm)

        if self.has_thrift_dependency:
            cm.comment('Add support for thrift')
            cm.set('Thrift_LIBRARIES', self.env.third_party_libs('thrift', 'rt', 'pthread'))
            cm.set('Thriftnb_LIBRARIES', self.env.third_party_libs('thriftnb', 'thrift', 'rt', 'event'))
            cm.newline()
            #--------------------------------------------------------------
            # Work around for http://bit.ly/HzNNw3
            cm.comment('----------------------------------------------------')
            cm.comment('This is to work around the following issue')
            cm.comment('https://issues.apache.org/jira/browse/THRIFT-1326')
            cm.cmd('ADD_DEFINITIONS', '-DHAVE_INTTYPES_H -DHAVE_NETINET_IN_H')
            cm.comment('----------------------------------------------------')
            #--------------------------------------------------------------
            cm.newline()

        if self.__incpath:
            cm.comment("Include paths")
            cm.cmd_list('INCLUDE_DIRECTORIES', self.__incpath)
            cm.newline()

        if self.__libpath:
            cm.comment("Library paths")
            cm.cmd_list('LINK_DIRECTORIES', self.__libpath)
            cm.newline()

        cm.comment("Thrifts include paths")
        cm.cmd_list('SET', ['THRIFTS_INCLUDE_DIRECTORIES'] + ["-I " + path for path in self.__thriftspath + ['/usr/share/thrifts']])
        cm.newline()

        self.__create_uninstall_target(cm)

        cm.commit()
        self.env.cmake()

    def do_build(self):
        self.env.build()

    def do_install(self):
        args = []
        if self.opt.install_destdir is not None:
            args.append('DESTDIR=' + self.opt.install_destdir)
        self.env.install(*args)

    def do_uninstall(self):
        self.env.uninstall()

    def do_clean(self):
        self.env.clean()

    def __forced_clean(self):
        try:
            self.do_clean()
        except RuntimeError:
            self.env.say("\n*** Cleaning failed, regenerating project files and retrying\n")
            self.env.realclean()
            self.do_clean()
            self.env.say("Second attempted appeared to work!")

    def do_realclean(self):
        self.__forced_clean()
        self.env.realclean()

        # We'll still remove an empty bin/ lib/ dirs, because cmake doesn't.
        self.env.remove_dirs('bin', 'lib')
        self.env.remove_files('config.cmake', 'install_manifest.txt')

    def find(self, pkg, **opts):
        if isinstance(pkg, basestring):
            pkg = CMakeFindPackageFactory.create(pkg, **opts)
        self.__pkgs.append(pkg)

class CMakeFind(object):
    _default_opts = {}
    _handled_pkgs = []

    def __init__(self, pkg = None, **opts):
        self._pkg = pkg
        self._optional = False
        self._opts = copy.deepcopy(self._default_opts)
        self._opts.update(opts)
        for attr in ['components', 'version', 'optional']:
            val = None
            if self._opts.has_key(attr):
                val = self._opts[attr]
                del self._opts[attr]
            if getattr(self, '_' + attr, None) is None or val is not None:
                setattr(self, '_' + attr, val)

    @classmethod
    def can_find(cls, pkg):
        return pkg in cls._handled_pkgs

    def configure(self, env, config, cm):
        env.vsay("Adding support for {0}.".format(self._pkg))
        cm.comment('configuration for {0} package'.format(self._pkg))
        self._do_configure(env, config, cm)

    def _do_configure(self, env, config, cm):
        pass

class CMakeFindBoost(CMakeFind):
    # On Windows Boost will link using 'Auto-Linking' so we don't need to do anything special
    _default_opts = {
      'use_static_libs': True,
      'use_multithreaded': True,
      'use_static_runtime': False,
      'components': 'date_time filesystem iostreams program_options regex serialization system thread unit_test_framework'.split(),
    }
    _handled_pkgs = ['boost']

    def __find_boost(self, cm, components):
        version = '' if self._version is None else ' {0}'.format(self._version)
        cm.writeln('FIND_PACKAGE(Boost{0}{1}'.format(version, ' COMPONENTS' if components else ''))
        if components:
            cm.write_list(components)
        cm.writeln(')')
        cm.newline()
        cm.c_if('Boost_FOUND')
        cm.cmd('INCLUDE_DIRECTORIES', 'SYSTEM', '${Boost_INCLUDE_DIR}')
        if not self._optional:
            cm.c_else()
            cm.cmd('MESSAGE', 'FATAL_ERROR "unable to locate {0}"'.format(self._pkg))
        cm.c_endif()
        cm.newline()

    def _do_configure(self, env, config, cm):
        # TODO: we could use the environment to grab some defaults from the .mirbuildrc's
        for k, v in sorted(self._opts.iteritems()):
            if v in [True, False]:
                cm.set('Boost_' + k.upper(), 'ON' if v else 'OFF')
            elif v is not None:
                cm.set('Boost_' + k.upper(), v)
        if config in ['debug'] and 'debug' not in self._opts:
            cm.set('Boost_DEBUG', 'ON')

        cm.newline()

        components = self._components
        self.__find_boost(cm, components)
        cm.set('Boost_TEST_LIBRARIES', '${Boost_LIBRARIES}')

        # If unit_test_framework is actually part of the components list (it is by default), run
        # FIND_PACKAGE(Boost) again, but without unit_test_framework, to populate Boost_LIBRARIES.
        # TODO: once all tests are using Boost_TEST_LIBRARIES, we can get rid of MIRBUILD_COMPATIBLE
        if 'unit_test_framework' in components and os.environ.get('MIRBUILD_COMPATIBLE', '1') == '0':
            components.remove('unit_test_framework')
            # Ouch, apparently FIND_PACKAGE(Boost) doesn't clear out Boost_LIBRARIES...
            cm.set('Boost_LIBRARIES', '')
            self.__find_boost(cm, components)

        # If we're using boost::thread, also link against pthread on non-windows platforms
        if 'thread' in self._components:
            cm.set('Boost_LIBRARIES', '${Boost_LIBRARIES} pthread')
            cm.set('Boost_TEST_LIBRARIES', '${Boost_TEST_LIBRARIES} pthread')

        cm.newline()

        # Ensure we're using v2 of Boost Filesystem
        # http://www.boost.org/doc/libs/1_47_0/libs/filesystem/v3/doc/index.htm
        # cm.cmd('ADD_DEFINITIONS', '-DBOOST_FILESYSTEM_VERSION=2')
        cm.newline()

class CMakeFindCurl(CMakeFind):
    _handled_pkgs = ['curl']

    def _do_configure(self, env, config, cm):
        cm.writeln('FIND_PACKAGE({0})'.format(self._pkg.upper()))
        cm.newline();
        cm.c_if('{0}_FOUND'.format(self._pkg.upper()))
        cm.cmd('INCLUDE_DIRECTORIES', 'SYSTEM', '${CURL_INCLUDE_DIR}')
        cm.set('Curl_LIBRARIES', '${CURL_LIBRARIES}') # just for case consistancy with the others
        if not self._optional:
            cm.c_else()
            cm.cmd('MESSAGE', 'FATAL_ERROR "unable to locate {0}"'.format(self._pkg))
        cm.c_endif()
        cm.newline()

class CMakeFindLua(CMakeFind):
    _handled_pkgs = ['lua50', 'lua51']

    def _do_configure(self, env, config, cm):
        cm.writeln('FIND_PACKAGE({0})'.format(self._pkg.title()))
        cm.newline();
        cm.c_if('{0}_FOUND'.format(self._pkg.upper()))
        cm.cmd('INCLUDE_DIRECTORIES', 'SYSTEM', '${LUA_INCLUDE_DIR}')
        # Augment the standard Lua libraries to include luabind (we wouldn't be using Lua without it!)
        cm.set('Lua_LIBRARIES', '${{LUA_LIBRARIES}} {0}'.format(env.third_party_libs('luabind')))
        if not self._optional:
            cm.c_else()
            cm.cmd('MESSAGE', 'FATAL_ERROR "unable to locate {0}"'.format(self._pkg))
        cm.c_endif()
        cm.newline()

class CMakeFindLog4cxx(CMakeFind):
    _handled_pkgs = ['log4cxx']

    def _do_configure(self, env, config, cm):
        cm.cmd('ADD_DEFINITIONS', '-DLOG4CXX_STATIC')
        if sys.platform in ['cygwin']:
            cm.set('Log4cxx_LIBRARIES', env.third_party_libs('log4cxx', 'apr-1', 'aprutil-1'))
        else:
            cm.set('Log4cxx_LIBRARIES', env.third_party_libs('log4cxx'))
        cm.newline()

class CMakeFindPackageFactory(object):
    implementations = [CMakeFindBoost, CMakeFindLua, CMakeFindCurl, CMakeFindLog4cxx]

    @classmethod
    def create(cls, pkg, **opts):
        cand = [c for c in cls.implementations if c.can_find(pkg)]
        if len(cand) != 1:
            raise RuntimeError('{0} CMakeFind candidates, please use a concrete implementation'.format('No' if not cand else 'Too many'))
        return cand[0](pkg, **opts)
